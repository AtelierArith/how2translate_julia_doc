---
title: 非英語圏における Julia ユーザのための技術
author: SatoshiTerasaki@AtelierArith
format:
  revealjs:
    theme: "black"
    css: "../styles/style.css"
    embed-resources: true
    slide-number: true
    show-notes: separate-page
    mermaid:
      theme: default
    gfm:
    mermaid-format: png
---

# 概要

- 非英語圏における Julia ユーザのために英語で記述されたドキュメントを翻訳する技術について紹介する．

---

## 背景

- プログラミング言語 Julia の公式ドキュメント・マニュアルは "英語" で書かれている．よって "英語" で概念を理解をする必要がある．
  - 日本語で書かれた解説書は数冊はでているものの，最先端の情報は英語で書かれた文章を読む必要がある．
- 必要に応じて GitHub の Issue, Julia の Discourse でコミュニケーションを（みんなが "英語" で書いてるので） "英語" で行うことになる．
  - このスライドを作成した人物は日本人であり日本語を母国語とする．
    - 当然，読み書きは日本語でする方が英語に比べて簡単・快適だと感じている．
  - 非英語圏の人間にとって英語を使ったコミュニケーションは心理的コスト・時間的コストは多かれ少なかれあると思われる．

## 心理的・時間的コストの定量化

(`Tatsuya Amano` 氏の投稿より)

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">英語が母語でない研究者はどれ程の不利益を被っているのでしょうか。日本を含む８か国での調査によって、論文読解・執筆・出版、発表準備や国際学会参加を行う際に、英語ネイティブ話者に比べて非ネイティブは非常に大きな時間や労力を費やしていることを定量化しました。<a href="https://t.co/Z6za22rMgg">https://t.co/Z6za22rMgg</a> <a href="https://t.co/88KfiBFPN9">pic.twitter.com/88KfiBFPN9</a></p>&mdash; Tatsuya Amano (@tatsuya_amano) <a href="https://twitter.com/tatsuya_amano/status/1681403577510809600?ref_src=twsrc%5Etfw">July 18, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

---

## どれだけ大変か

`Tatsuya Amano` 氏の投稿より (https://x.com/tatsuya_amano/status/1681403580648140800 )

> この問題は英語が母語でない研究者に多大な影響をもたらします。調査参加者の多くから、英語で科学を行うために「途方もない時間」と「経済的な負担」が必要で、大きな「ストレスと不安」を感じ、結果として「多くの研究が出版されず」「才能ある人材がキャリアを諦めている」という声が上がりました。

<br>

研究者というある種の専門家でさえ困難を極めている．一般の人々なら尚更．

## 実は英語はとても難しいのでは

- プログラミング言語 JuliaLang は柔軟なプログラミングを可能にしながら実行速度を担保する．
  - `two-language problem` を解決している．
  - `Why We Created Julia`
    - `In short, because we are greedy.`
    - `We are greedy: we want more.`

- 非英語圏の人間はもっと`欲張り (=greedy)` になってもいいのでは？

## 実は英語はとても難しいのでは

- 自然言語における $(N \geq 2)$ -language problem が潜在的にあるのでは？
  - 同様に非英語圏における Julia ユーザをサポートがあってもいいのでは?
  - 母国語でマニュアルを読み思考する権利があってのいいのでは?
  - 母国語でドキュメントを書く権利があってもいいのでは?
    - 論理的に言えば日本語でドキュメントを書くことは可能
- あるのは経済的な障壁である．

## 経済的な障壁

- 英語で書かれているマニュアルを翻訳するには手間がかかる．
- バージョンが更新された際に翻訳箇所をアップデートする必要がある．それに追従するための手間がかかる．

これらの手間に対する対価を誰が支払うのか？

JuliaHub 日本支社があれば是非入社したいが残念ながらそのようなポストは見つけられていない．

## 機械翻訳の利用

（多少ぎこちなくても)機械に任せよう．

- Google 翻訳
- DeepL、ChatGPT などの大規模言語モデル（LLM）を用いた解決策

このスライドでは ChatGPT の API を利用した翻訳方法について紹介する．

## Docstring の翻訳

- AtelierArith/DocstringTranslation.jl: Translate docstrings in Julia into your preferred language.
- AtelierArith/DocstringTranslationOllamaBackend.jl: DocstringTranslation using Ollama
- AtelierArith/DocstringTranslationGoogleTransBackend.jl: Translate Julia's docstring using googletrans
- AtelierArith/DocstringTranslationExoBackend.jl: Translate Julia's docstrings using `exo`: Run your own AI cluster at home with everyday devices
- AtelierArith/DocstringChef.jl: May I explain something?

---

### How to use `DocstringTranslation.jl`

```julia
julia> using DotEnv; DotEnv.load!(); 
julia> using DocstringTranslation; @switchlang! :Japanese
julia> @doc exp
  exp(x)

  xの自然基底指数を計算します。言い換えれば、ℯ^xです。

  他にexp2、exp10、およびcisも参照してください。

  例
  ≡≡

  julia> exp(1.0)
  2.718281828459045

  julia> exp(im * pi) ≈ cis(pi)
  true

  exp(A::AbstractMatrix)

  行列 A
  の行列指数関数を計算します。これは次のように定義されます。


e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.


  対称行列またはエルミート行列 A
  に対しては、固有分解（eigen）が使用され、それ以外の場合はスケーリングと平方化アルゴリズムが選択されます（詳細は
  [^H05] を参照）。

  │ [^H05]
  │
  │  Nicholas J. Higham, "The squaring and scaling
  │  method for the matrix exponential revisited",
  │  SIAM Journal on Matrix Analysis and
  │  Applications, 26(4), 2005, 1179-1193.
  │  doi:10.1137/090768539
  │  (https://doi.org/10.1137/090768539)

  例
  ≡≡

  julia> A = Matrix(1.0I, 2, 2)
  2×2 Matrix{Float64}:
   1.0  0.0
   0.0  1.0

  julia> exp(A)
  2×2 Matrix{Float64}:
   2.71828  0.0
   0.0      2.71828
```

- ChatGPT API モデルとして `gpt-4o-mini-2024-07-18` を使用している．

## Docstring 翻訳の原理

- `@doc sin` などを呼ばれたときメソッド `Docs.parsedoc(d::DocStr)` が呼ばれる．このメソッドをハックする．

```julia
lang = "Japanese"
switchlang!(lang)
@eval function Docs.parsedoc(d::DocStr)
    if d.object === nothing
        md = Docs.formatdoc(d)
        md.meta[:module] = d.data[:module]
        md.meta[:path] = d.data[:path]
        d.object = md
    end
    # d.object # <-- original implementation
    translate_with_openai(d.object) # <-- hack implementation
end
```

Markdown オブジェクト `d.object` を所望の内容に変換することで目的を達成できる．

---

### `Documenter.jl` による Markdown の翻訳

- マークダウン 1枚を丸ごと翻訳させる (End-to-End) を考えることもできる．
  - DocstringTranslation.jl は Ent-to-End
- Documenter.jl シンタックスを用いたマークダウンの翻訳は難しい

---

### `Documenter.jl` による Markdown の翻訳

- 実はそこまで簡単ではない
  - マークダウンの構造を壊す可能性がある 
    - backtick の抜け漏れの可能性
    - 翻訳結果が表す数式モードルール
  - ソースコードブロックも含めて翻訳すると `doctest` 実行時に失敗する可能性がある．
  - `[xxx](@ref yyy)` という Documenter の `cross_references` を表す構文が翻訳されると不都合が生じる
    - `xxx` や `yyy` の箇所を翻訳すると `cross_references` チェック時にビルドが失敗する
  - `xxx` として `Header{n}` を指すケースがあるので安易に翻訳ができない．

- 小さいトークンの入力を複数実行するほうが一度に全ての文章を翻訳させるより速度が速い．

---

## `Markdown.parse` 結果の利用

なるべくマークダウンの構造を壊さないように翻訳をする必要がある．

`Markdown.parse` の結果を利用して翻訳対象と翻訳するべきでない対象を区別する．

```julia
julia> md = Markdown.parse("See [Julia docs](https://docs.julialang.org/en/v1/) to learn more")
  See Julia docs (https://docs.julialang.org/en/v1/) to
  learn more

julia> md.content
1-element Vector{Any}:
 Markdown.Paragraph(Any["See ", Markdown.Link(Any["Julia docs"], "https://docs.julialang.org/en/v1/"), " to learn more"])
```

上記の例だと `Markdown.Link` の部分は翻訳を避けたい．それ以外は翻訳したい．

## `Markdown.Link` の置き換え

何かしらの方法で `Markdown.Link(Any["Julia docs"], "https://docs.julialang.org/en/v1/")` を `asfa93r_bfeafasf` のように ID に変換する．

翻訳後に ID を元に戻す.

```julia
julia> md = Markdown.parse("詳しくは `asfa93r_bfeafasf` を見てください")
  See asfa93r_bfeafasf to learn more

julia> md.content
1-element Vector{Any}:
 Markdown.Paragraph(Any["詳しくは", Markdown.Code("", "asfa93r_bfeafasf"), "を見てください"])
```

`Markdown.Code("", "asfa93r_bfeafasf")` の部分を `Markdown.Link(Any["Julia docs"], "https://docs.julialang.org/en/v1/")` に置き換える．こうすると "概ね" cross reference に関するエラーを回避できる．（改善の余地はある）

## 詳細な実装

```julia
function
    (bytes2hex(codeunits(join(l.text))) * "_" * bytes2hex(codeunits(l.url)))
end

function _translate!(p::Markdown.Paragraph)
    hex2link = Dict()
    link2hex = Dict()
    content = map(p.content) do c
        # Protect Link so that it does not break during translation
        if c isa Markdown.Link
            h = _create_hex(c)
            hex2link[string(h)] = c
            link2hex[c] = h
            "`" * h * "`"
        else
            c
        end
    end
    p_orig = deepcopy(p)
    p.content = content
    result = translate_documenter_md_with_openai(Markdown.MD(p))
    try
        translated_content = map(result[1].content) do c
            if c isa Markdown.Code
                if isempty(c.language)
                    if c.code in keys(hex2link)
                        _c = hex2link[c.code]
                        delete!(hex2link, c.code)
                        c = _c
                        c
                    else
                        c
                    end
                else
                    c
                end
            else
                c
            end
        end
        if isempty(hex2link)
            p.content = translated_content
        else
            @warn "Failed to translate by hex2link"
            p.content = p_orig.content
        end
    catch e
        @warn "Failed to translate by $(e)" p
        p.content = p_orig.content
    end
    nothing
end

function _translate!(list::Markdown.List)
    for item in list.items
        Base.Threads.@threads for i in item
            _translate!(i)
        end
    end
end

function _translate!(c)
    if hasproperty(c, :content)
        Base.Threads.@threads for c in c.content
            _translate!(c)
        end
    end
    c
end

function translate_md!(md::Markdown.MD)
    Base.Threads.@threads for c in md.content
        _translate!(c)
    end
    md
end
```

---

### `Documenter.Page(source, build, workdir` のハック

Documenter.jl がマークダウンファイルを読み込むタイミングで翻訳機構を挿入する．

```julia
function Documenter.Page(
    source::AbstractString,
    build::AbstractString,
    workdir::AbstractString,
)
    # The Markdown standard library parser is sensitive to line endings:
    #   https://github.com/JuliaLang/julia/issues/29344
    # This can lead to different AST and therefore differently rendered docs, depending on
    # what platform the docs are being built (e.g. when Git checks out LF files with
    # CRFL line endings on Windows). To make sure that the docs are always built consistently,
    # we'll normalize the line endings when parsing Markdown files by removing all CR characters.
    
    if !isfile(joinpath("jp", relpath(source)))
        mdsrc = replace(read(source, String), '\r' => "")
        mdpage = Markdown.parse(mdsrc)
        @info "Translating ..." mdpage
        mdpage = translate!(mdpage)
        @info "Translated" mdpage
        # end DocstringTranslationOllamaBackend
        mkpath(dirname(joinpath("jp", relpath(source))))
        write(joinpath("jp", relpath(source)), string(mdpage))
    else
         @info "Translating ..." joinpath("jp", relpath(source))
        mdsrc = replace(read(joinpath("jp", relpath(source)), String), '\r' => "")
        mdpage = Markdown.parse(mdsrc)
    end
    # end DocstringTranslationOllamaBackend
    mdast = try
        convert(Documenter.MarkdownAST.Node, mdpage)
    catch err
        @error """
        MarkdownAST conversion error on $(source).
        This is a bug — please report this on the Documenter issue tracker
        """
        rethrow(err)
    end
    return Documenter.Page(
        source,
        build,
        workdir,
        mdpage.content,
        Documenter.Globals(),
        mdast,
    )
end
```

## 成果物

- [UnofficialJuliaDoc-ja](https://atelierarith.github.io/UnofficialJuliaDoc-ja/) 日本語
- [UnofficialJuliaDoc-de](https://atelierarith.github.io/UnofficialJuliaDoc-de/) ドイツ語
- [UnofficialJuliaDoc-fr](https://atelierarith.github.io/UnofficialJuliaDoc-fr/) フランス語
- [UnofficialJuliaDoc-es](https://atelierarith.github.io/UnofficialJuliaDoc-es/) スペイン語

せっかくなので Documenter.jl の日本語翻訳版も置いておくね．

- [JapaneseTranslatedDocumenterHTML](https://atelierarith.github.io/JapaneseTranslatedDocumenterHTML/)

---
 
## 翻訳結果の再利用

- Scratch.jl を用いて翻訳結果をキャッシュする仕組みを採用．
  - 途中でエラーが起きても翻訳したものを再利用し復帰することが可能．
  - `~/.julia/scrathspace/<UUID>/translation` というディレクトリに格納される

```julia
using Scratch
const TRANSLATION_CACHE_DIR = Ref{String}()

function __init__()
    global TRANSLATION_CACHE_DIR[] = @get_scratch!("translation")
end

function istranslated(md::Markdown.MD)
    cachedir = TRANSLATION_CACHE_DIR[]
    lang = DEFAULT_LANG[]
    isfile(joinpath(cachedir, hashmd(md), lang * ".md"))
end

function load_translation(hash::String)
    cachedir = TRANSLATION_CACHE_DIR[]
    lang = DEFAULT_LANG[]
    Markdown.parse(
        postprocess_content(read(joinpath(cachedir, hash, lang * ".md"), String)),
    )
end

function cache_original(md::Markdown.MD)
    cachedir = TRANSLATION_CACHE_DIR[]
    mkpath(joinpath(cachedir, hashmd(md)))
    write(joinpath(cachedir, hashmd(md), "original.md"), string(md))
end

function cache_translation(hash::String, transmd::Markdown.MD)
    cachedir = TRANSLATION_CACHE_DIR[]
    lang = DEFAULT_LANG[]
    mkpath(joinpath(cachedir, hash))
    write(joinpath(cachedir, hash, lang * ".md"), string(transmd))
end
```

---

## よくわかってないこと

- パラグラフを検出し翻訳する箇所はスレッドをいっぱい作成して並列に回すことで強引に翻訳を高速している．
  - 要するに HTTP リクエストを大量に発行する方法
  - もっと良い方法はある？
  - 丸ごと翻訳するよりトークン数を節約できる．
- docstring の並列翻訳する方法
- `translation` ディレクトリの共有方法
  - Artifact の機能を使えば良いかもしれない．

---

## 以上

ありがとうございました．

---

# Appendix

`@switchlang!` macro の実装

```julia
"""
    @switchlang!(lang)

Modify Docs.parsedoc(d::DocStr) to insert translation engine.
"""
macro switchlang!(lang)
    @eval function Docs.parsedoc(d::DocStr)
        if d.object === nothing
            md = Docs.formatdoc(d)
            md.meta[:module] = d.data[:module]
            md.meta[:path] = d.data[:path]
            d.object = md
        end
        cache_original(d.object)
        hash = hashmd(d.object)
        if istranslated(d.object)
            transmd = load_translation(hash)
            return transmd
        else
            transmd = translate_docstring_with_openai(d.object)
            cache_translation(hash, transmd)
            return transmd
        end
    end

    # Overrides Page constructor to hack Documenter to translate docstrings
    @eval function Documenter.Page(
        source::AbstractString,
        build::AbstractString,
        workdir::AbstractString,
    )
        # The Markdown standard library parser is sensitive to line endings:
        #   https://github.com/JuliaLang/julia/issues/29344
        # This can lead to different AST and therefore differently rendered docs, depending on
        # what platform the docs are being built (e.g. when Git checks out LF files with
        # CRFL line endings on Windows). To make sure that the docs are always built consistently,
        # we'll normalize the line endings when parsing Markdown files by removing all CR characters.

        mdsrc = replace(read(source, String), '\r' => "")
        mdpage = Markdown.parse(mdsrc)
        cache_original(mdpage)
        @info "Translating ..." mdpage
        hashvalue = hashmd(mdpage)
        if !istranslated(mdpage)
            # Update mdpage object
            mdpage = translate_md!(mdpage)
            # end DocstringTranslationOllamaBackend
            cache_translation(hashvalue, mdpage)
        else
            mdpage = load_translation(hashvalue)
        end
        @info "Translated" mdpage
        # end DocstringTranslationOllamaBackend
        mdast = try
            convert(Documenter.MarkdownAST.Node, mdpage)
        catch err
            @error """
            MarkdownAST conversion error on $(source).
            This is a bug — please report this on the Documenter issue tracker
            """
            rethrow(err)
        end
        return Documenter.Page(
            source,
            build,
            workdir,
            mdpage.content,
            Documenter.Globals(),
            mdast,
        )
    end
    quote
        local _lang = $(esc(lang))
        _switchlang!(_lang)
    end
end
```