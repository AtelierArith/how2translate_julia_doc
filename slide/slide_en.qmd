---
title: Techniques for Julia Users in Non-English Speaking Regions
author: SatoshiTerasaki@AtelierArith
format:
  revealjs:
    theme: "black"
    css: "../styles/style.css"
    embed-resources: true
    slide-number: true
    show-notes: separate-page
    mermaid:
      theme: default
    gfm:
    mermaid-format: png
---

# Overview

- Introducing techniques for translating documents written in English for Julia users in non-English speaking regions.

---

## Background

- The official documentation and manuals for the programming language Julia are written in "English." Therefore, it is necessary to understand concepts in "English."
  - Although there are a few explanatory books written in Japanese, cutting-edge information requires reading texts written in English.
- When necessary, communication on GitHub Issues and Julia Discourse will be in "English" (since everyone writes in "English").
  - The person who created this slide is Japanese and a native Japanese speaker.
    - Naturally, they find it easier and more comfortable to read and write in Japanese compared to English.
  - It is believed that there is a psychological and time cost, to a greater or lesser extent, for non-English speakers.

## Quantifying Psychological and Time Costs

(From a post by `Tatsuya Amano`)

<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">How much disadvantage do researchers who are not native English speakers face? Through a survey in eight countries, including Japan, we quantified that non-native speakers spend significantly more time and effort compared to native English speakers when reading, writing, publishing papers, preparing presentations, and participating in international conferences. <a href="https://t.co/Z6za22rMgg">https://t.co/Z6za22rMgg</a> <a href="https://t.co/88KfiBFPN9">pic.twitter.com/88KfiBFPN9</a></p>&mdash; Tatsuya Amano (@tatsuya_amano) <a href="https://twitter.com/tatsuya_amano/status/1681403577510809600?ref_src=twsrc%5Etfw">July 18, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

---

## How Difficult It Is

From a post by `Tatsuya Amano` (https://x.com/tatsuya_amano/status/1681403580648140800)

> This issue greatly affects researchers who are not native English speakers. Many survey participants reported that conducting science in English requires "enormous time" and "financial burden," causing significant "stress and anxiety," and as a result, "many studies are not published" and "talented individuals abandon their careers."

<br>

Even experts like researchers find it extremely challenging. It is even more so for the general public.

## Is English Actually Very Difficult?

- The programming language JuliaLang enables flexible programming while ensuring execution speed.
  - It solves the `two-language problem`.
  - `Why We Created Julia`
    - `In short, because we are greedy.`
    - `We are greedy: we want more.`

- Shouldn't non-English speakers also become more `greedy`?

## Is English Actually Very Difficult?

- Is there a potential $(N \geq 2)$ -language problem in natural languages?
  - Similarly, shouldn't there be support for Julia users in non-English speaking regions?
  - Shouldn't there be a right to read and think in one's native language?
  - Shouldn't there be a right to write documents in one's native language?
    - Logically speaking, it is possible to write documents in Japanese.
- The barrier is economic.

## Economic Barriers

- Translating manuals written in English is labor-intensive.
- When a version is updated, it is necessary to update the translated sections. Keeping up with this requires effort.

Who will pay for this effort?

If there were a JuliaHub Japan branch, I would love to join, but unfortunately, I haven't found such a position.

## Use of Machine Translation

(Let's leave it to the machine, even if it's a bit awkward.)

- Google Translate
- Solutions using large language models (LLM) like DeepL, ChatGPT

This slide introduces a translation method using the ChatGPT API.

## Translation of Docstrings

- AtelierArith/DocstringTranslation.jl: Translate docstrings in Julia into your preferred language.
- AtelierArith/DocstringTranslationOllamaBackend.jl: DocstringTranslation using Ollama
- AtelierArith/DocstringTranslationGoogleTransBackend.jl: Translate Julia's docstring using googletrans
- AtelierArith/DocstringTranslationExoBackend.jl: Translate Julia's docstrings using `exo`: Run your own AI cluster at home with everyday devices
- AtelierArith/DocstringChef.jl: May I explain something?

---

### How to use `DocstringTranslation.jl`

```julia
julia> using DotEnv; DotEnv.load!(); 
julia> using DocstringTranslation; @switchlang! :Japanese
julia> @doc exp
  exp(x)

  xの自然基底指数を計算します。言い換えれば、ℯ^xです。

  他にexp2、exp10、およびcisも参照してください。

  例
  ≡≡

  julia> exp(1.0)
  2.718281828459045

  julia> exp(im * pi) ≈ cis(pi)
  true

  exp(A::AbstractMatrix)

  行列 A
  の行列指数関数を計算します。これは次のように定義されます。


e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.


  対称行列またはエルミート行列 A
  に対しては、固有分解（eigen）が使用され、それ以外の場合はスケーリングと平方化アルゴリズムが選択されます（詳細は
  [^H05] を参照）。

  │ [^H05]
  │
  │  Nicholas J. Higham, "The squaring and scaling
  │  method for the matrix exponential revisited",
  │  SIAM Journal on Matrix Analysis and
  │  Applications, 26(4), 2005, 1179-1193.
  │  doi:10.1137/090768539
  │  (https://doi.org/10.1137/090768539)

  例
  ≡≡

  julia> A = Matrix(1.0I, 2, 2)
  2×2 Matrix{Float64}:
   1.0  0.0
   0.0  1.0

  julia> exp(A)
  2×2 Matrix{Float64}:
   2.71828  0.0
   0.0      2.71828
```

- Using `gpt-4o-mini-2024-07-18` as the ChatGPT API model.

## Principle of Docstring Translation

- When `@doc sin` is called, the method `Docs.parsedoc(d::DocStr)` is invoked. This method is hacked.

```julia
lang = "Japanese"
switchlang!(lang)
@eval function Docs.parsedoc(d::DocStr)
    if d.object === nothing
        md = Docs.formatdoc(d)
        md.meta[:module] = d.data[:module]
        md.meta[:path] = d.data[:path]
        d.object = md
    end
    # d.object # <-- original implementation
    translate_with_openai(d.object) # <-- hack implementation
end
```

By converting the Markdown object `d.object` to the desired content, the goal can be achieved.

---

### Translation of Markdown with `Documenter.jl`

- It is possible to consider translating an entire Markdown page (End-to-End).
  - DocstringTranslation.jl is End-to-End
- Translating Markdown using Documenter.jl syntax is difficult

---

### Translation of Markdown with `Documenter.jl`

- It's actually not that simple
  - There is a possibility of breaking the Markdown structure
    - Possibility of missing backticks
    - Translation results may affect mathematical mode rules
  - Translating including source code blocks may cause failures during `doctest` execution.
  - If Documenter's `cross_references` syntax like `[xxx](@ref yyy)` is translated, it causes issues
    - Translating the `xxx` part causes build failures during `cross_references` checks
  - Since `xxx` may refer to `Header{n}`, it cannot be easily translated.

- Executing multiple small token inputs is faster than translating all sentences at once.

---

## Use of `Markdown.parse` Results

It is necessary to translate without breaking the Markdown structure as much as possible.

Use the results of `Markdown.parse` to distinguish between what should and should not be translated.

```julia
julia> md = Markdown.parse("See [Julia docs](https://docs.julialang.org/en/v1/) to learn more")
  See Julia docs (https://docs.julialang.org/en/v1/) to
  learn more

julia> md.content
1-element Vector{Any}:
 Markdown.Paragraph(Any["See ", Markdown.Link(Any["Julia docs"], "https://docs.julialang.org/en/v1/"), " to learn more"])
```

In the above example, the `Markdown.Link` part should be avoided in translation. Everything else should be translated.

## Replacement of `Markdown.Link`

Convert `Markdown.Link(Any["Julia docs"], "https://docs.julialang.org/en/v1/")` into an ID like `asfa93r_bfeafasf` by some method.

Restore the ID after translation.

```julia
julia> md = Markdown.parse("詳しくは `asfa93r_bfeafasf` を見てください")
  See asfa93r_bfeafasf to learn more

julia> md.content
1-element Vector{Any}:
 Markdown.Paragraph(Any["詳しくは", Markdown.Code("", "asfa93r_bfeafasf"), "を見てください"])
```

Replace the part `Markdown.Code("", "asfa93r_bfeafasf")` with `Markdown.Link(Any["Julia docs"], "https://docs.julialang.org/en/v1/")`. This can "generally" avoid errors related to cross-references. (There is room for improvement)

## Detailed Implementation

```julia
function create_hex(l::Markdown.Link)
    (bytes2hex(codeunits(join(l.text))) * "_" * bytes2hex(codeunits(l.url)))
end

function translate!(p::Markdown.Paragraph)
    hex2link = Dict()
    link2hex = Dict()
    content = map(p.content) do c
        # Protect Link so that it does not break during translation
        if c isa Markdown.Link
            h = create_hex(c)
            hex2link[string(h)] = c
            link2hex[c] = h
            "`" * h * "`"
        else
            c
        end
    end
    p_orig = deepcopy(p)
    p.content = content
    result = translate_with_openai(Markdown.MD(p), lang = "Japanese")
    try
        translated_content = map(result[1].content) do c
            if c isa Markdown.Code
                if isempty(c.language)
                    c = get(hex2link, c.code, c)
                else
                    c
                end
            else
                c
            end
        end
        p.content = translated_content
    catch e
        @warn "Failed to translate by $(e)" p
        return p_orig
    end
    return p
end

function translate!(list::Markdown.List)
    for item in list.items
        Base.Threads.@threads for i in item
            translate!(i)
        end
    end
end

function translate!(c)
    if hasproperty(c, :content)
        Base.Threads.@threads for c in c.content
            translate!(c)
        end
    end
    c
end

function translate!(md::Markdown.MD)
    Base.Threads.@threads for c in md.content
        translate!(c)
    end
    md
end
```

## Hack for `Documenter.Page(source, build, workdir`

Insert the translation mechanism when Documenter.jl reads the markdown file.

```julia
function Documenter.Page(
    source::AbstractString,
    build::AbstractString,
    workdir::AbstractString,
)
    # The Markdown standard library parser is sensitive to line endings:
    #   https://github.com/JuliaLang/julia/issues/29344
    # This can lead to different AST and therefore differently rendered docs, depending on
    # what platform the docs are being built (e.g. when Git checks out LF files with
    # CRFL line endings on Windows). To make sure that the docs are always built consistently,
    # we'll normalize the line endings when parsing Markdown files by removing all CR characters.
    
    if !isfile(joinpath("jp", relpath(source)))
        mdsrc = replace(read(source, String), '\r' => "")
        mdpage = Markdown.parse(mdsrc)
        @info "Translating ..." mdpage
        mdpage = translate!(mdpage)
        @info "Translated" mdpage
        # end DocstringTranslationOllamaBackend
        mkpath(dirname(joinpath("jp", relpath(source))))
        write(joinpath("jp", relpath(source)), string(mdpage))
    else
         @info "Translating ..." joinpath("jp", relpath(source))
        mdsrc = replace(read(joinpath("jp", relpath(source)), String), '\r' => "")
        mdpage = Markdown.parse(mdsrc)
    end
    # end DocstringTranslationOllamaBackend
    mdast = try
        convert(Documenter.MarkdownAST.Node, mdpage)
    catch err
        @error """
        MarkdownAST conversion error on $(source).
        This is a bug — please report this on the Documenter issue tracker
        """
        rethrow(err)
    end
    return Documenter.Page(
        source,
        build,
        workdir,
        mdpage.content,
        Documenter.Globals(),
        mdast,
    )
end
```

## Outcomes

- https://atelierarith.github.io/UnofficialJuliaDocJP/
- https://atelierarith.github.io/JapaneseTranslatedDocumenterHTML/

## Things Not Well Understood

- The part that detects and translates paragraphs is forcefully sped up by creating many threads and running them in parallel.
  - In short, a method to issue a large number of HTTP requests
  - Is there a better way?
  - It can save tokens compared to translating the whole thing.

- Management of translation result cache
  - Translating every time takes time.
      - A method to manage translated results by associating them with hash keys
      - There seems to be a way to use Scratch.jl for translation results.
  - Would a package like DocstringBankJP.jl be nice to have?
